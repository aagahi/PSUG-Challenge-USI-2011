package org.psug.usi.store

/**
 * User: alag
 * Date: 2/16/11
 * Time: 11:26 PM
 */
import collection.mutable.HashMap
import java.io.Serializable

trait Data[K<:Any] extends Serializable {
  def storeKey:K
  def copyWithAutoGeneratedId( autoGeneratedId:K ):Data[K]
}

trait DataRepositoryMessage

case class StoreData[K<:Any]( data:Data[K] ) extends DataRepositoryMessage
case class DataStored[K<:Any,T<:Data[K]]( errorEitherData:Either[String,T] ) extends DataRepositoryMessage

case class PullData[K<:Any]( key:K ) extends DataRepositoryMessage
case class DataPulled[K<:Any]( data:Option[Data[K]] ) extends DataRepositoryMessage

case object ClearRepository extends DataRepositoryMessage

trait DataRepository[K<:Any,T<:Data[K]] {

  def handleMessage( any:Any ) = {
    any match{
      case StoreData( data ) if( data.isInstanceOf[T]) => DataStored[K,T]( store( data.asInstanceOf[T] ) )
      case PullData( key ) if( key.isInstanceOf[K] ) => DataPulled[K]( findByStoreKey( key.asInstanceOf[K] ) )
      case ClearRepository => reset
      case x => throw new Exception( "Unexpected message " + any )
    }
  }

  /**
   * Check the data abides by the constraint for this store.
   *
   * @return None if data is valid, Some(message) if data is invalid.
   */
  protected def checkConstraint( data:T ):Option[String]


  /**
   * @return  send back a T with same characteristics but with (unique) id defined, or an error message
   */
  protected def store(data : T):Either[String,T]

  /**
   * @return Some(T) if games with id registered in repository, or None
   */
  protected def findByStoreKey(key : K):Option[T]

  /**
   * clear this repository's content.
   */
  protected def reset : Unit
}


/**
 * Stores users in memory, using an actor to serialize access to underlying map.
 */
// TODO: should not use K<:Any for the storeKey...
class InMemoryDataRepository[T<:Data[Int]] extends DataRepository[Int,T] {

  private var currentId = 0
  protected var dataByKey  : HashMap[Int,T] = new HashMap()

  override protected def checkConstraint(data:T) : Option[String] = None
  
  override protected def store(data : T) = {
    currentId += 1
    val copyData = data.copyWithAutoGeneratedId(currentId).asInstanceOf[T]
    ( checkConstraint( copyData ) ) match {
      case None =>
        dataByKey( copyData.storeKey ) = copyData
        Right( copyData )
      case Some(message)  =>
        Left( "Invalid store contraint: "+ message )
    }
  }

  override protected def findByStoreKey(key : Int) = dataByKey.get(key)

  override protected def reset { currentId = 0;  dataByKey.clear }
}
