package org.psug.usi.store

/**
 * User: alag
 * Date: 2/16/11
 * Time: 11:26 PM
 */
import collection.mutable.HashMap
import java.io.Serializable

trait Data[K<:Any] {
  def storeKey:K
  def copyWithAutoGeneratedId( autoGeneratedId:Int ):Data[K]
}

trait DataRepositoryMessage

trait DataRepository[K<:Any,T<:Data[K]] extends Serializable {


  case class StoreData( data:T ) extends DataRepositoryMessage
  case class DataStored( errorEitherData:Either[String,T] ) extends DataRepositoryMessage

  case class PullData( key : K ) extends DataRepositoryMessage
  case class DataPulled( data:Option[T] ) extends DataRepositoryMessage

  case class ClearRepository( dummy:Int = 0 ) extends DataRepositoryMessage

  def handleMessage( any:Any ) = {
    if( any.isInstanceOf[StoreData]) DataStored( store( any.asInstanceOf[StoreData].data ) )
    else if( any.isInstanceOf[PullData] ) DataPulled( findByStoreKey( any.asInstanceOf[PullData].key ) )
    else if( any.isInstanceOf[ClearRepository] ){ reset }
    else {
      any match{
        /* => does not work with remote actor... scala bug?
        case StoreData( data ) => DataStored( store( data ) )
        case PullData( key ) => DataPulled( findByStoreKey( key ) )
        case Clear => reset
        */
        case x => throw new Exception( "Unexpected message " + any )
      }
    }

  }



    /**
     * @return  true if data contrains are respected
     */
  protected def checkConstraint( data:T ):Boolean

  /**
   * @return  send back a T with same characteristics but with (unique) id defined, or an error message
   */
  protected def store(data : T):Either[String,T]

  /**
   * @return Some(T) if games with id registered in repository, or None
   */
  protected def findByStoreKey(key : K):Option[T]

  /**
   * clear this repository's content.
   */
  protected def reset : Unit
}



/**
 * Stores users in memory, using an actor to serialize access to underlying map.
 */
// TODO: should not use K<:Any for the storeKey...
class InMemoryDataRepository[K<:Any,T<:Data[K]] extends DataRepository[K,T] {

  private var currentId = 0
  protected var dataByKey  : HashMap[K,T] = new HashMap()

  override protected def checkConstraint(data:T) = true
  
  override protected def store(data : T) = {
    currentId += 1
    val copyData = data.copyWithAutoGeneratedId(currentId).asInstanceOf[T]
    if( checkConstraint( copyData ) ){
      dataByKey( copyData.storeKey ) = copyData
      Right( copyData )
    }
    else {
      Left( "Invalid store contraint" )
    }

  }

  override protected def findByStoreKey(key : K) = dataByKey.get(key)


  override protected def reset { currentId = 0;  dataByKey.clear }
}
