package org.psug.usi.store

/**
 * User: alag
 * Date: 2/16/11
 * Time: 11:26 PM
 */
import collection.mutable.HashMap
import java.io.Serializable

trait Data[K<:Any] {
  def storeKey:K
  def copyWithAutoGeneratedId( autoGeneratedId:Int ):Data[K]
}

trait DataRepositoryMessage

case class StoreData[K<:Any]( data:Data[K] ) extends DataRepositoryMessage
case class DataStored[K<:Any,T<:Data[K]]( errorEitherData:Either[String,T] ) extends DataRepositoryMessage

case class PullData[K<:Any]( key:K ) extends DataRepositoryMessage
case class DataPulled[K<:Any]( data:Option[Data[K]] ) extends DataRepositoryMessage

case object ClearRepository extends DataRepositoryMessage


trait DataRepository[K<:Any,T<:Data[K]] {



  def handleMessage( any:Any ) = {
    any match{
      case StoreData( data ) if( data.isInstanceOf[T]) => DataStored[K,T]( store( data.asInstanceOf[T] ) )
      case PullData( key ) if( key.isInstanceOf[K] ) => DataPulled[K]( findByStoreKey( key.asInstanceOf[K] ) )
      case ClearRepository => reset
      case x => throw new Exception( "Unexpected message " + any )
    }
  }



    /**
     * @return  true if data contrains are respected
     */
  protected def checkConstraint( data:T ):Boolean

  /**
   * @return  send back a T with same characteristics but with (unique) id defined, or an error message
   */
  protected def store(data : T):Either[String,T]

  /**
   * @return Some(T) if games with id registered in repository, or None
   */
  protected def findByStoreKey(key : K):Option[T]

  /**
   * clear this repository's content.
   */
  protected def reset : Unit
}



/**
 * Stores users in memory, using an actor to serialize access to underlying map.
 */
// TODO: should not use K<:Any for the storeKey...
class InMemoryDataRepository[K<:Any,T<:Data[K]] extends DataRepository[K,T] {

  private var currentId = 0
  protected var dataByKey  : HashMap[K,T] = new HashMap()

  override protected def checkConstraint(data:T) = true
  
  override protected def store(data : T) = {
    currentId += 1
    val copyData = data.copyWithAutoGeneratedId(currentId).asInstanceOf[T]
    if( checkConstraint( copyData ) ){
      dataByKey( copyData.storeKey ) = copyData
      Right( copyData )
    }
    else {
      Left( "Invalid store contraint" )
    }

  }

  override protected def findByStoreKey(key : K) = dataByKey.get(key)


  override protected def reset { currentId = 0;  dataByKey.clear }
}
