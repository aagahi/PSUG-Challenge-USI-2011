package org.psug.usi.store

import com.sleepycat.je._
import com.sleepycat.bind.tuple.{IntegerBinding}
import java.io._
import rep.{NoConsistencyRequiredPolicy, ReplicatedEnvironment, ReplicationConfig}


/**
 * User: alag
 * Date: 3/5/11
 * Time: 1:31 PM
 */


object BDBEnvironment {
  val cacheSizeInByte = 1024*1024*8
  val replicaGroupName = "ChallengeUSI"
  val nodeName = "Node1"
  val replicaHostName = "localhost:5501"
  val replicaHelperHostName = "localhost:5501"

  val envHome = new File( "./bdb" )

  var openDatabases = Set[Database]()

  Runtime.getRuntime().addShutdownHook( new ShutdownHook )
  

  lazy val environment = {
    val envConfig = new EnvironmentConfig()
    envConfig.setAllowCreate( true )

    envConfig.setCacheSize( cacheSizeInByte )
    //envConfig.setCachePercent( 5 )
    envConfig.setSharedCache( true )

    envConfig.setTransactional( true )


    val durability = new Durability(Durability.SyncPolicy.WRITE_NO_SYNC,
                                    Durability.SyncPolicy.NO_SYNC,
                                    Durability.ReplicaAckPolicy.NONE )

    envConfig.setDurability( durability )

    /*
    new Environment( envHome, envConfig )
    */

    println( "Starting replicated environment on " + replicaHostName + " contacting helper " + replicaHelperHostName)

    val repConfig = new ReplicationConfig()
    repConfig.setGroupName( replicaGroupName )
    repConfig.setNodeName( nodeName )
    repConfig.setNodeHostPort( replicaHostName )
    repConfig.setDesignatedPrimary(true)
    repConfig.setHelperHosts( replicaHelperHostName )

    repConfig.setConsistencyPolicy( new NoConsistencyRequiredPolicy() )

    new ReplicatedEnvironment( envHome, repConfig, envConfig )
  }

  def registerDatabase( database:Database ){
    openDatabases += database
  }
  def unregisterDatabase( database:Database ){
    openDatabases -= database
  }



  def shutdown() {
    openDatabases.foreach( _.close )
    environment.sync()
    environment.cleanLog()
    environment.close()
  }


  class ShutdownHook extends Thread {
    override def run() {
        println( "Shutting down databases" )
          shutdown
    }
  }

}

trait BDB[T<:Data[Int]]
{
  import BDBEnvironment._
  
  val databaseName:String
  lazy val dbFolder = new File( envHome, databaseName )

  private var _database:Database = null

  def database = {
    if( _database == null ){
      if( !dbFolder.exists() ) dbFolder.mkdirs()
      val dbConfig = new DatabaseConfig()
      dbConfig.setAllowCreate( true )
      dbConfig.setTransactional( true )
      dbConfig.setDeferredWrite( false )
      _database = environment.openDatabase(null, databaseName, dbConfig );
      registerDatabase( _database )
    }
    _database
  }

  def close() {
    database.close()
    unregisterDatabase( database )
    _database = null
  }

  def removeDatabase() {
    close()
    environment.removeDatabase( null, databaseName )
  }

  def store( id:Int, in:T ) {
    val tx = environment.beginTransaction( null, null )
    val key = new DatabaseEntry()
    IntegerBinding.intToEntry( id, key )

    val baos = new ByteArrayOutputStream()
    val oos = new ObjectOutputStream( baos )
    oos.writeObject( in )

    val data = new DatabaseEntry( baos.toByteArray )
    database.put( null, key, data )

    tx.commit()
  }


  def lastIndex = {
    val cursor = database.openCursor(null, null)
    try{
      val key = new DatabaseEntry()
      val data = new DatabaseEntry()
      cursor.getLast( key, data, LockMode.DEFAULT );
      if( key.getData() != null ){
          IntegerBinding.entryToInt( key )
      }
      else 0
    }
    finally {
      cursor.close()
    }

 }

  def load( id:Int ):Option[T] = {
    //val tx = environment.beginTransaction( null, null )
    val key = new DatabaseEntry()
    IntegerBinding.intToEntry( id, key )

    val data = new DatabaseEntry()

    database.get( null, key, data, LockMode.READ_UNCOMMITTED )
    val buffer = data.getData
    if( buffer != null ) {
        val ois = new ObjectInputStream( new ByteArrayInputStream( buffer ))
        Some( ois.readObject().asInstanceOf[T] )


    }
    else None
  }

  def delete( id:Int ) {
    //val tx = environment.beginTransaction( null, null )
    val key = new DatabaseEntry()
    IntegerBinding.intToEntry( id, key )
    database.delete( null, key )
    //tx.commit()
  }


}

/**
 * Stores users in memory, using an actor to serialize access to underlying map.
 */
class BDBDataRepository[T<:Data[Int]]( override val databaseName:String ) extends DataRepository[Int,T] with BDB[T] {

  private var currentId = lastIndex

  override protected def checkConstraint(data:T) = true

  override protected def store(data : T) = {
    currentId += 1
    val copyData = data.copyWithAutoGeneratedId(currentId).asInstanceOf[T]
    if( checkConstraint( copyData ) ){
      store( currentId, copyData )
      Right( copyData )
    }
    else {
      Left( "Invalid store contraint" )
    }

  }

  override protected def findByStoreKey(key : Int) = load( key )

  override protected def reset { currentId = 0;  removeDatabase }
}
