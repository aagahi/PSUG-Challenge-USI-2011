package org.psug.usi.store

import com.sleepycat.je._
import com.sleepycat.bind.tuple.{IntegerBinding}
import java.io._

/**
 * User: alag
 * Date: 3/5/11
 * Time: 1:31 PM
 */


trait BDB[T<:Data[Int]]
{
  val databaseName:String

  val cacheSizeInByte = 1024*1024*8

  lazy val dbFolder = new File( databaseName )
  lazy val environment:Environment = getEnvironment


  private var _database:Database = null

  def database = {
    if( _database == null ){
      val dbConfig = new DatabaseConfig()
      dbConfig.setAllowCreate( true )
      dbConfig.setTransactional( false )
      dbConfig.setDeferredWrite( false )
      _database = environment.openDatabase(null, databaseName, dbConfig );
    }
    _database
  }


  def getEnvironment =
  {
    val envConfig = new EnvironmentConfig()
    envConfig.setAllowCreate( true )
    envConfig.setCacheSize( cacheSizeInByte )

    //envConfig.setCachePercent( 5 );
    envConfig.setSharedCache( false )
    envConfig.setTransactional( false )
    //envConfig.setDurability( Durability.COMMIT_NO_SYNC )
    if( !dbFolder.exists() ) dbFolder.mkdirs()
    new Environment( dbFolder, envConfig )
  }



  def shutdown() {
    database.close()
    environment.sync()
    environment.cleanLog()
    environment.close()
  }


  def removeDatabase() {
    database.close()
    environment.removeDatabase( null, databaseName );
    _database = null
  }

  def store( id:Int, in:T ) {
    //val tx = environment.beginTransaction( null, null )
    val key = new DatabaseEntry()
    IntegerBinding.intToEntry( id, key )

    val baos = new ByteArrayOutputStream()
    val oos = new ObjectOutputStream( baos )
    oos.writeObject( in )

    val data = new DatabaseEntry( baos.toByteArray )
    database.put( null, key, data )

    //tx.commit()
  }


  def load( id:Int ):Option[T] = {
    //val tx = environment.beginTransaction( null, null )
    val key = new DatabaseEntry()
    IntegerBinding.intToEntry( id, key )

    val data = new DatabaseEntry()

    database.get( null, key, data, LockMode.READ_UNCOMMITTED )
    val buffer = data.getData
    if( buffer != null ) {
        val ois = new ObjectInputStream( new ByteArrayInputStream( buffer ))
        Some( ois.readObject().asInstanceOf[T] )


    }
    else None
  }

  def delete( id:Int ) {
    //val tx = environment.beginTransaction( null, null )
    val key = new DatabaseEntry()
    IntegerBinding.intToEntry( id, key )
    database.delete( null, key )
    //tx.commit()
  }


}

/**
 * Stores users in memory, using an actor to serialize access to underlying map.
 */
// TODO: should not use K<:Any for the storeKey...
class BDBDataRepository[T<:Data[Int]]( override val databaseName:String ) extends DataRepository[Int,T] with BDB[T] {

  private var currentId = 0
  //protected var dataByKey  : HashMap[K,T] = new HashMap()

  override protected def checkConstraint(data:T) = true

  override protected def store(data : T) = {
    currentId += 1
    val copyData = data.copyWithAutoGeneratedId(currentId).asInstanceOf[T]
    if( checkConstraint( copyData ) ){
      store( currentId, copyData )
      Right( copyData )
    }
    else {
      Left( "Invalid store contraint" )
    }

  }

  override protected def findByStoreKey(key : Int) = load( key )


  override protected def reset { currentId = 0;  removeDatabase }
}
